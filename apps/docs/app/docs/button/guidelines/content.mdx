import { Button, Flex, Box, Text, Callout, IconButton, Theme, Section, Separator, Badge, Image } from '@kushagradhawan/kookie-ui';
import { TriangleAlertIcon, ChevronDown, SquareCheckBig, ChevronRight, Plus, Bookmark } from 'lucide-react';
import { CodeBlock } from '../../../components/code-block';

<Section size="1">

# Guidelines

Design buttons as promises that users can trust. When someone sees a button, they form expectations about what will happen when they tap it. Honor those expectations and guide people toward successful task completion.

</Section>

<Separator size="4"/>



<Section size="1">

## Hierarchy

Create clear button hierarchies that guide users toward successful outcomes.

### Clear Path

Guide users toward one primary action per interface section. Multiple competing primary actions create decision paralysis and reduce conversion rates.

<CodeBlock 
  preview={
    <Flex gap="2" align="center">
      <Button size="3" variant="solid"><SquareCheckBig/> Complete</Button>
      <Button size="3" variant="outline"><Bookmark/>Save</Button>
    </Flex>
  }
/>

Make the primary action obvious at a glance. Secondary actions should enable the primary action or provide necessary alternatives.

### Progressive Disclosure

Start with the most common path and reveal additional options progressively. Don't overwhelm users with choices.

### Spatial Relationships

Use button positioning to reinforce hierarchy. Primary actions typically appear on the right in Western interfaces, while secondary actions appear on the left.

Group related actions together and separate unrelated ones. Proximity communicates relationship.

</Section>

<Separator size="4"/>


<Section size="1">

## Context

Consider context when choosing visual treatments. The same visual treatment can feel appropriate or jarring depending on context.

Think about where users are in their journey. Are they exploring options or ready to commit? The context determines which visual treatment will feel natural and supportive.

</Section>

<Separator size="4"/>



<Section size="1">

## Trust

Build user confidence through consistent button treatments. When similar actions look similar across your interface, users develop confidence in your system.

Avoid inconsistent button treatments that force users to pause and evaluate each interaction. This breaks flow states and increases abandonment.

</Section>

<Separator size="4"/>



<Section size="1">

## Variants

Use each variant to serve specific psychological and contextual needs. Think of these as tools for communicating intent and guiding user behavior.

### Solid

Use solid buttons for primary importance and to build user confidence in critical actions. The solid background creates maximum contrast against most interface backgrounds.

<CodeBlock
  preview={
    <Flex gap="2" align="center">
      <Button size="3" variant="solid">Button</Button>
      <Button size="3" variant="solid" color="teal">Button</Button>
    </Flex>
  }
/>

Choose solid buttons for primary workflow completion, high-stakes confirmations, and call-to-action buttons in marketing contexts.

### Outline

Use outline buttons to provide definite affordance while maintaining visual restraint. The border creates clear boundaries without competing for attention.

<CodeBlock
  preview={
    <Flex gap="2" align="center">
      <Button size="3" variant="outline" color="crimson">Button</Button>
      <Button size="3" variant="outline" color="gray">Button</Button>
    </Flex>
  }
/>

Choose outline buttons for secondary actions alongside primary buttons, alternative paths that shouldn't overshadow the main action, and exploration actions.

### Ghost

Use ghost buttons for utility actions that should be discoverable but not prominent. They remain nearly invisible until interaction.

<CodeBlock
  preview={
    <Flex gap="2" align="center">
      <Button size="3" variant="ghost">Button</Button>
      <Button size="3" variant="ghost"><Plus />Button</Button>
    </Flex>
  }
/>

Choose ghost buttons for utility functions, secondary navigation, content actions, and administrative functions that support the main workflow.

### Soft

Use soft buttons to provide color presence without harsh boundaries. They integrate naturally with content while maintaining clear interactive affordance.

<CodeBlock
  preview={
    <Flex gap="2" align="center">
      <Button size="3" variant="soft">Button</Button>
      <Button size="3" variant="soft" color="iris">Button</Button>
    </Flex>
  }
/>

Choose soft buttons for content-area actions, gentle calls-to-action in text-heavy layouts, and interface sections where harsh contrasts feel inappropriate.

### Surface

Use surface buttons to combine background and border for consistent appearance across varying container backgrounds.

<CodeBlock
  preview={
    <Flex gap="2" align="center">
      <Button size="3" variant="surface">Button</Button>
      <Button size="3" variant="surface" color="iris">Button</Button>
    </Flex>
  }
/>

Choose surface buttons for modular components used in multiple contexts, buttons on cards with changing background colors, and dynamic layouts where background varies.

### Classic

Use classic buttons for sophisticated shadow systems that create depth. They feel like physical objects that respond to touch.

<CodeBlock
  preview={
    <Flex gap="2" align="center">
      <Button size="3" variant="classic">Button</Button>
      <Button size="3" variant="classic" color="iris">Button</Button>
    </Flex>
  }
/>

Choose classic buttons for standalone focal points in spacious layouts, premium interface experiences, hero sections and marketing contexts, and applications where physical metaphors enhance usability.

</Section>

<Separator size="4"/>

<Section size="1">

## Material

Choose material to define the fundamental substance from which your interface is constructed. Digital materials create different experiences and expectations.

### Solid

Use solid material to create interfaces that feel grounded and reliable. Solid materials provide clear boundaries and predictable behavior.

<CodeBlock
  preview={
    <Flex gap="2" align="center">
      <Button size="3" variant="solid">Button</Button>
      <Button size="3" variant="outline">Button</Button>
    </Flex>
  }
/>

Choose solid material for primary interfaces, data-heavy applications, and contexts where clarity and reliability are paramount.

### Translucent

Use translucent material to create interfaces that feel layered and responsive to their environment. They reveal context while maintaining their own identity.

<CodeBlock
  background="https://images.unsplash.com/photo-1677504210210-b9259daf154f?q=80&w=2728&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D"
  backgroundProps={{
    height: "100%",
    width: "100%",
    radius: "3"
  }}
  preview={
    <Flex gap="2" align="center" justify="center" wrap="wrap" width="100%">
      <Button highContrast size="3" color="gray" variant="classic" material="translucent">Button</Button>
      <Button size="3" color="" variant="solid" material="translucent">Button</Button>
    </Flex>
  }
/>

Choose translucent material for overlay interfaces, hero sections, and contexts where you want to create visual depth and connection to background content.

### Experience

Consider your application's purpose and the user's mental state when choosing between solid and translucent materials. Are they focused on completing specific tasks, or are they exploring and discovering?

Solid materials create interfaces that feel like tools: precise, reliable, and focused on task completion. Translucent materials create interfaces that feel like environments: immersive, contextual, and responsive to their surroundings.

Choose materials that match the functional and emotional requirements of your interface context.

</Section>

<Separator size="4"/>



<Section size="1">

## Mistakes

Avoid these common button design problems that break user expectations and create friction.

**Decision paralysis through competing primary actions** is the most common mistake. When multiple solid buttons appear in the same interface section, users don't know which action you want them to take. Establish clear hierarchy where one action is obviously primary and others support that choice.

**Inconsistent visual treatments** across your interface force users to relearn your system at every interaction. When similar actions look different in different contexts, users lose confidence in their ability to predict behavior.

</Section>

<Separator size="4"/>


<Section size="1">

## Accessibility

Design buttons that work for everyone, regardless of ability or interaction method.

### Contrast and Visibility

Choose button treatments that provide sufficient contrast for users with visual impairments. **Solid buttons** offer the highest contrast with white text on colored backgrounds.

**High contrast mode** automatically enhances color saturation and contrast ratios when users need maximum visibility. Use the `highContrast` prop for buttons that appear over complex backgrounds.

### Touch Targets

Design buttons that accommodate users with varying motor abilities. **Size 3 (40px)** and **Size 4 (48px)** provide adequate touch targets for mobile interfaces and users with motor impairments.

### Clear Communication

Design button text that communicates clearly to screen reader users. Use descriptive labels like "Save changes" or "View product details" that explain the action's outcome.

When buttons contain only icons, always provide accessible labels through tooltips or `aria-label` attributes.

### Focus and Navigation

Design interfaces that support keyboard navigation naturally. Ensure that button sequences follow logical tab order, and that focus indicators are clearly visible.

### Loading States

Design loading states that communicate progress clearly to all users. Ensure that loading text is descriptive ("Saving your changes..." rather than just "Loading...").

</Section>

<Separator size="4"/>

<Section size="1">

## Implementation

For technical implementation details, see [API](./api). For design tokens and specifications, see [Specs](./specs).

</Section>

