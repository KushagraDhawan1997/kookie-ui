import { Table, Text, Code, Box, Callout, Badge, Section, Heading, Card, Flex, Separator } from '@kushagradhawan/kookie-ui';
import { CodeBlock } from '../../components/code-block';

<Section size="1">

<Badge size="2" variant="soft" highContrast color="orange" style={{ alignSelf: 'flex-start' }}>Beta</Badge>

# Guidelines

Design shell layouts as structural foundations that users can trust. When someone encounters a shell layout, they instantly form expectations about navigation, content organization, and interaction patterns. Your job as a designer is to honor those expectations and create interfaces that guide people naturally toward successful task completion.

</Section>

<Separator size="4"/>

<Section size="1">

## Spatial Hierarchy

Create effective layout hierarchies by understanding how people scan and navigate interfaces. The shell's seven-slot system provides predictable spatial relationships that reduce cognitive load and guide users toward their goals.

### Visual Weight Distribution

Use the shell's slots to create clear visual hierarchy. Primary navigation should feel stable and accessible, while secondary content should be discoverable but not competing for attention. This follows the principle that not every piece of information needs equal visual weight.

<Callout.Root variant="soft" size="2" color="blue" my="7">
  <Callout.Text>People develop spatial memory of your interface. Consistent slot usage helps users build mental models of where to find things, reducing search time and increasing confidence.</Callout.Text>
</Callout.Root>

### Slot-Based Architecture

The Shell uses a seven-slot system that covers the most common application layout patterns:

<Box>
  <Table.Root mt="6" mb="9" size="2" variant="ghost">
    <Table.Header>
      <Table.Row>
        <Table.ColumnHeaderCell>Slot</Table.ColumnHeaderCell>
        <Table.ColumnHeaderCell>Purpose</Table.ColumnHeaderCell>
        <Table.ColumnHeaderCell>Usage</Table.ColumnHeaderCell>
      </Table.Row>
    </Table.Header>
    <Table.Body>
      <Table.Row>
        <Table.RowHeaderCell>`Header`</Table.RowHeaderCell>
        <Table.Cell>Global navigation and branding</Table.Cell>
        <Table.Cell>App bar, search, user menu, breadcrumbs</Table.Cell>
      </Table.Row>
      <Table.Row>
        <Table.RowHeaderCell>`Rail`</Table.RowHeaderCell>
        <Table.Cell>Primary navigation strip</Table.Cell>
        <Table.Cell>Icon-based navigation, section switching</Table.Cell>
      </Table.Row>
      <Table.Row>
        <Table.RowHeaderCell>`Panel`</Table.RowHeaderCell>
        <Table.Cell>Secondary navigation/tools</Table.Cell>
        <Table.Cell>Expanded navigation, file trees, tool palettes</Table.Cell>
      </Table.Row>
      <Table.Row>
        <Table.RowHeaderCell>`Sidebar`</Table.RowHeaderCell>
        <Table.Cell>Alternative to Rail+Panel</Table.Cell>
        <Table.Cell>Combined navigation, content management</Table.Cell>
      </Table.Row>
      <Table.Row>
        <Table.RowHeaderCell>`Content`</Table.RowHeaderCell>
        <Table.Cell>Main work area</Table.Cell>
        <Table.Cell>Primary application interface, documents</Table.Cell>
      </Table.Row>
      <Table.Row>
        <Table.RowHeaderCell>`Inspector`</Table.RowHeaderCell>
        <Table.Cell>Contextual information</Table.Cell>
        <Table.Cell>Properties, metadata, contextual actions</Table.Cell>
      </Table.Row>
      <Table.Row>
        <Table.RowHeaderCell>`Bottom`</Table.RowHeaderCell>
        <Table.Cell>Secondary workspace</Table.Cell>
        <Table.Cell>Terminals, logs, notifications, debug info</Table.Cell>
      </Table.Row>
    </Table.Body>
  </Table.Root>
</Box>

### State vs. Content Separation

<Callout.Root variant="soft" size="2" color="blue" my="7">
  <Callout.Text>The Shell manages layout state (expanded/collapsed, sizes, presentation) but does not manage content state (navigation, data, application logic).</Callout.Text>
</Callout.Root>

**Shell manages:**
- Pane visibility (expanded/collapsed)
- Responsive presentation (fixed/overlay/stacked)
- Size persistence and constraints
- Animation timing and behavior

**Your application manages:**
- Navigation state and routing
- Content loading and data
- User preferences and settings
- Business logic and workflows

</Section>

<Separator size="4"/>

<Section size="1">

## Layout Patterns

Choose layout patterns based on your users' mental models and task complexity. Each pattern communicates different levels of information hierarchy and supports different types of user workflows.

### Rail + Panel Pattern

Use this pattern when users need both quick section switching and detailed navigation. The rail provides immediate orientation, while the panel offers context-sensitive details. This creates a two-level navigation hierarchy that matches how people think about complex information structures.

**Psychological benefits:**
- Reduces cognitive load by separating global and local navigation
- Provides spatial consistency for muscle memory
- Supports both exploration and focused work modes

<CodeBlock>

```tsx
<Shell.Root>
  <Shell.Header>
    <AppNavigation />
  </Shell.Header>
  
  <Shell.Rail defaultSize={64}>
    <PrimaryNavigation /> {/* Icons for main sections */}
  </Shell.Rail>
  
  <Shell.Panel defaultSize={288} resizable>
    <SecondaryNavigation /> {/* Detailed navigation for current section */}
  </Shell.Panel>
  
  <Shell.Content>
    <MainInterface />
  </Shell.Content>
  
  <Shell.Inspector defaultMode="collapsed">
    <PropertiesPanel />
  </Shell.Inspector>
</Shell.Root>
```

</CodeBlock>

**When to use:**
- Complex applications with multiple sections
- File explorers and content management systems
- Development tools and IDEs
- Design applications with tool palettes

### Sidebar Pattern

Use this pattern when you want unified navigation that can adapt to different screen sizes and user preferences. The sidebar creates a single source of truth for navigation, reducing decision fatigue and providing a consistent spatial reference.

**Psychological benefits:**
- Creates a single, predictable navigation location
- Reduces cognitive overhead of multiple navigation areas
- Supports progressive disclosure through expand/collapse states

<CodeBlock>

```tsx
<Shell.Root>
  <Shell.Header>
    <AppNavigation />
  </Shell.Header>
  
  <Shell.Sidebar 
    defaultMode={{ initial: 'collapsed', md: 'expanded' }}
    thinSize={64}
  >
    <UnifiedNavigation /> {/* Combined navigation */}
  </Shell.Sidebar>
  
  <Shell.Content>
    <MainInterface />
  </Shell.Content>
</Shell.Root>
```

</CodeBlock>

**When to use:**
- Simpler applications with unified navigation
- Dashboard and analytics interfaces
- Documentation sites
- Marketing and content sites

### Content-Only Pattern

Use this pattern when the interface itself is the primary focus and navigation should be minimal or contextual. This creates a distraction-free environment that supports deep work and focused attention.

**Psychological benefits:**
- Eliminates visual noise and competing elements
- Supports flow states and sustained attention
- Reduces decision fatigue by limiting choices

<CodeBlock>

```tsx
<Shell.Root>
  <Shell.Header height={48}>
    <MinimalNavigation />
  </Shell.Header>
  
  <Shell.Content>
    <FocusedInterface />
  </Shell.Content>
</Shell.Root>
```

</CodeBlock>

**When to use:**
- Document editors and writing tools
- Presentation and display modes
- Kiosk interfaces
- Single-purpose applications

</Section>

<Separator size="4"/>

<Section size="1">

## Responsive Strategy

### Mobile-First Approach

Design layouts that work on mobile first, then enhance for larger screens:

<CodeBlock>

```tsx
<Shell.Sidebar
  defaultMode={{
    initial: 'collapsed',  // Mobile: start collapsed
    sm: 'thin',           // Tablet: show icons only
    lg: 'expanded'        // Desktop: full navigation
  }}
  presentation={{
    initial: 'overlay',   // Mobile: overlay to preserve content
    md: 'fixed'          // Desktop: fixed for persistent access
  }}
>
  <ResponsiveNavigation />
</Shell.Sidebar>
```

</CodeBlock>

### Breakpoint Strategy

<Box>
  <Table.Root mt="6" mb="9" size="2" variant="ghost">
    <Table.Header>
      <Table.Row>
        <Table.ColumnHeaderCell>Breakpoint</Table.ColumnHeaderCell>
        <Table.ColumnHeaderCell>Typical Pattern</Table.ColumnHeaderCell>
        <Table.ColumnHeaderCell>Considerations</Table.ColumnHeaderCell>
      </Table.Row>
    </Table.Header>
    <Table.Body>
      <Table.Row>
        <Table.RowHeaderCell>`initial` (mobile)</Table.RowHeaderCell>
        <Table.Cell>Collapsed panes, overlay presentation</Table.Cell>
        <Table.Cell>Preserve content space, touch-friendly</Table.Cell>
      </Table.Row>
      <Table.Row>
        <Table.RowHeaderCell>`sm` (tablet)</Table.RowHeaderCell>
        <Table.Cell>Thin sidebars, selective expansion</Table.Cell>
        <Table.Cell>Balance navigation and content</Table.Cell>
      </Table.Row>
      <Table.Row>
        <Table.RowHeaderCell>`md` (laptop)</Table.RowHeaderCell>
        <Table.Cell>Fixed presentation, expanded navigation</Table.Cell>
        <Table.Cell>Persistent navigation becomes viable</Table.Cell>
      </Table.Row>
      <Table.Row>
        <Table.RowHeaderCell>`lg` (desktop)</Table.RowHeaderCell>
        <Table.Cell>Full layouts, multiple panels</Table.Cell>
        <Table.Cell>Take advantage of screen real estate</Table.Cell>
      </Table.Row>
      <Table.Row>
        <Table.RowHeaderCell>`xl` (wide)</Table.RowHeaderCell>
        <Table.Cell>Expanded inspectors, wider content</Table.Cell>
        <Table.Cell>Consider content line length limits</Table.Cell>
      </Table.Row>
    </Table.Body>
  </Table.Root>
</Box>

### Presentation Modes

<Callout.Root variant="soft" size="2" color="gray" my="7">
  <Callout.Text>Choose presentation modes based on content priority and screen constraints.</Callout.Text>
</Callout.Root>

**Fixed**: Pane always visible, takes up layout space
- Use when navigation is frequently accessed
- Best for desktop and larger screens
- Provides consistent spatial relationships

**Overlay**: Pane appears over content when expanded
- Use when content needs maximum space
- Best for mobile and smaller screens
- Preserves content area completely

**Stacked**: Pane pushes content aside (sheet-like behavior)
- Use for temporary or contextual panels
- Good for inspectors and secondary tools
- Provides clear visual hierarchy

</Section>

<Separator size="4"/>

<Section size="1">

## Content Guidelines

### Navigation Hierarchy

Structure navigation to match your application's information architecture:

<CodeBlock>

```tsx
<Shell.Rail>
  {/* Top-level sections */}
  <NavItem icon={<DashboardIcon />} href="/dashboard" />
  <NavItem icon={<ProjectsIcon />} href="/projects" />
  <NavItem icon={<SettingsIcon />} href="/settings" />
</Shell.Rail>

<Shell.Panel>
  {/* Context-sensitive navigation */}
  {currentSection === 'projects' && (
    <ProjectNavigation>
      <ProjectList />
      <RecentFiles />
      <ProjectActions />
    </ProjectNavigation>
  )}
</Shell.Panel>
```

</CodeBlock>

### Inspector Content

Keep inspector content focused and contextual:

<CodeBlock>

```tsx
<Shell.Inspector defaultMode="collapsed">
  {selectedItem ? (
    <ItemInspector item={selectedItem}>
      <Properties />
      <Actions />
      <Metadata />
    </ItemInspector>
  ) : (
    <EmptyState>
      <Text>Select an item to view properties</Text>
    </EmptyState>
  )}
</Shell.Inspector>
```

</CodeBlock>

### Bottom Panel Usage

Use bottom panels for secondary workflows that don't interrupt the main interface:

<CodeBlock>

```tsx
<Shell.Bottom 
  defaultMode="collapsed"
  defaultSize={240}
  minSize={120}
  maxSize={400}
>
  <Tabs defaultValue="terminal">
    <TabsList>
      <TabsTrigger value="terminal">Terminal</TabsTrigger>
      <TabsTrigger value="logs">Logs</TabsTrigger>
      <TabsTrigger value="problems">Problems</TabsTrigger>
    </TabsList>
    
    <TabsContent value="terminal">
      <Terminal />
    </TabsContent>
    <TabsContent value="logs">
      <LogViewer />
    </TabsContent>
    <TabsContent value="problems">
      <ProblemList />
    </TabsContent>
  </Tabs>
</Shell.Bottom>
```

</CodeBlock>

</Section>

<Separator size="4"/>

<Section size="1">

## Sizing Guidelines

### Default Sizes

Use consistent sizing that balances functionality with content space:

<Box>
  <Table.Root mt="6" mb="9" size="2" variant="ghost">
    <Table.Header>
      <Table.Row>
        <Table.ColumnHeaderCell>Component</Table.ColumnHeaderCell>
        <Table.ColumnHeaderCell>Recommended Size</Table.ColumnHeaderCell>
        <Table.ColumnHeaderCell>Min/Max</Table.ColumnHeaderCell>
        <Table.ColumnHeaderCell>Usage</Table.ColumnHeaderCell>
      </Table.Row>
    </Table.Header>
    <Table.Body>
      <Table.Row>
        <Table.RowHeaderCell>`Rail`</Table.RowHeaderCell>
        <Table.Cell>64px</Table.Cell>
        <Table.Cell>48-80px</Table.Cell>
        <Table.Cell>Icon navigation, minimal text</Table.Cell>
      </Table.Row>
      <Table.Row>
        <Table.RowHeaderCell>`Panel`</Table.RowHeaderCell>
        <Table.Cell>288px</Table.Cell>
        <Table.Cell>200-480px</Table.Cell>
        <Table.Cell>Navigation lists, file trees</Table.Cell>
      </Table.Row>
      <Table.Row>
        <Table.RowHeaderCell>`Sidebar`</Table.RowHeaderCell>
        <Table.Cell>288px (64px thin)</Table.Cell>
        <Table.Cell>200-480px</Table.Cell>
        <Table.Cell>Combined navigation</Table.Cell>
      </Table.Row>
      <Table.Row>
        <Table.RowHeaderCell>`Inspector`</Table.RowHeaderCell>
        <Table.Cell>320px</Table.Cell>
        <Table.Cell>280-480px</Table.Cell>
        <Table.Cell>Property panels, metadata</Table.Cell>
      </Table.Row>
      <Table.Row>
        <Table.RowHeaderCell>`Bottom`</Table.RowHeaderCell>
        <Table.Cell>200px</Table.Cell>
        <Table.Cell>120-400px</Table.Cell>
        <Table.Cell>Terminals, logs, notifications</Table.Cell>
      </Table.Row>
    </Table.Body>
  </Table.Root>
</Box>

### Resizing Constraints

Set appropriate constraints to maintain usability:

<CodeBlock>

```tsx
<Shell.Panel
  defaultSize={288}
  minSize={200}    // Minimum for readable content
  maxSize={480}    // Maximum to preserve content space
  resizable={true}
  collapsible={false} // Prevent accidental collapse
>
  <Navigation />
</Shell.Panel>
```

</CodeBlock>

### Size Persistence

Implement size persistence for frequently adjusted panes:

<CodeBlock>

```tsx
const sizeStorage = {
  load: () => {
    const saved = localStorage.getItem('inspector-size');
    return saved ? parseInt(saved, 10) : undefined;
  },
  save: (size: number) => {
    localStorage.setItem('inspector-size', size.toString());
  }
};

<Shell.Inspector
  defaultSize={320}
  persist={sizeStorage}
>
  <InspectorContent />
</Shell.Inspector>
```

</CodeBlock>

</Section>

<Separator size="4"/>

<Section size="1">

## Animation Principles

### Collapse/Expand Timing

The Shell uses a two-phase animation system:

1. **Collapse**: Content fades out first, then container animates
2. **Expand**: Container animates first, then content fades in

This prevents content from appearing compressed or awkwardly positioned during transitions.

### Performance Considerations

<Callout.Root variant="soft" size="2" color="yellow" my="7">
  <Callout.Text>Avoid placing heavy animations or frequent updates in shell panes, as layout changes can trigger expensive reflows.</Callout.Text>
</Callout.Root>

**Best practices:**
- Use CSS transforms instead of layout properties when possible
- Debounce resize operations for performance
- Consider using `will-change` CSS property for animated elements
- Test animation performance on lower-end devices

</Section>

<Separator size="4"/>

<Section size="1">

## Common Patterns

### File Explorer Pattern

<CodeBlock>

```tsx
<Shell.Root>
  <Shell.Header>
    <FileExplorerHeader />
  </Shell.Header>
  
  <Shell.Rail defaultSize={64}>
    <FileTypeFilters />
  </Shell.Rail>
  
  <Shell.Panel defaultSize={320} resizable>
    <DirectoryTree />
  </Shell.Panel>
  
  <Shell.Content>
    <FileGrid />
  </Shell.Content>
  
  <Shell.Inspector>
    <FileDetails />
  </Shell.Inspector>
</Shell.Root>
```

</CodeBlock>

### Dashboard Pattern

<CodeBlock>

```tsx
<Shell.Root>
  <Shell.Header>
    <DashboardHeader />
  </Shell.Header>
  
  <Shell.Sidebar 
    defaultMode={{ initial: 'collapsed', lg: 'expanded' }}
  >
    <DashboardNavigation />
  </Shell.Sidebar>
  
  <Shell.Content>
    <DashboardGrid />
  </Shell.Content>
</Shell.Root>
```

</CodeBlock>

### Development Tool Pattern

<CodeBlock>

```tsx
<Shell.Root>
  <Shell.Header height={48}>
    <ToolHeader />
  </Shell.Header>
  
  <Shell.Sidebar thinSize={64}>
    <ToolNavigation />
  </Shell.Sidebar>
  
  <Shell.Content>
    <Editor />
  </Shell.Content>
  
  <Shell.Inspector>
    <DevTools />
  </Shell.Inspector>
  
  <Shell.Bottom defaultMode="collapsed">
    <Terminal />
  </Shell.Bottom>
</Shell.Root>
```

</CodeBlock>

</Section>

<Separator size="4"/>

<Section size="1">

## Troubleshooting

### Composition Conflicts

**Problem**: Console warning about Sidebar with Rail/Panel
**Solution**: Use either Rail+Panel OR Sidebar, not both

<CodeBlock>

```tsx
// ❌ Invalid: Causes composition conflict
<Shell.Root>
  <Shell.Sidebar>...</Shell.Sidebar>
  <Shell.Rail>...</Shell.Rail>
  <Shell.Panel>...</Shell.Panel>
</Shell.Root>

// ✅ Valid: Use one pattern
<Shell.Root>
  <Shell.Sidebar>...</Shell.Sidebar>
  {/* OR */}
  <Shell.Rail>...</Shell.Rail>
  <Shell.Panel>...</Shell.Panel>
</Shell.Root>
```

</CodeBlock>

### Size Persistence Issues

**Problem**: Sizes not persisting across sessions
**Solution**: Check persistence adapter implementation

<CodeBlock>

```tsx
// ✅ Proper async persistence
const persistence = {
  load: async () => {
    try {
      const saved = await storage.get('panel-size');
      return saved ? parseInt(saved, 10) : undefined;
    } catch {
      return undefined; // Fallback on error
    }
  },
  save: async (size: number) => {
    try {
      await storage.set('panel-size', size.toString());
    } catch {
      // Handle save errors gracefully
    }
  }
};
```

</CodeBlock>

### Responsive Behavior Issues

**Problem**: Layout not responding to breakpoint changes
**Solution**: Ensure responsive objects are properly structured

<CodeBlock>

```tsx
// ✅ Proper responsive configuration
<Shell.Sidebar
  defaultMode={{
    initial: 'collapsed',
    md: 'expanded'
  }}
  presentation={{
    initial: 'overlay',
    lg: 'fixed'
  }}
>
```

</CodeBlock>

</Section>

<Separator size="4"/>